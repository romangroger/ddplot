#include <math.h>
#include <stdlib.h>

#include "ddplot.h"
#include "messages.h"
#include "neighlist.h"
#include "pltwin.h"
#include "rdf.h"


/* This function finds the nearest neighbors of atoms up to the cutoff distance specified by
  maxdist. The PLT files generated by BOP do not give periodicity in x, y and z direction but
  instead the size of the block in these directions.  However, in some PLT files the three numbers
  refer to periodicity.  ALL .PLT FILES SHOULD GIVE PERIODICITY ALONG X,Y,Z DIRECTIONS. */

bool InitNeighborList(PltWin *pw, IMatrix &nnlist, IVector &nnum)
{
  double dist, dx, dy, dz, dmin, dmax;
  IVector icell(3), icmin(3), icmax(3);
  int icen, ineigh, idx, i, d, nn, iidx, jidx, kidx;
  bool ok;

  // allocate the space for data
  nnlist.Allocate(pw->NInit,MAX_NEIGHBORS);
  nnlist.EnlargeStep(0,MAX_NEIGHBORS);
  nnlist = END_OF_LIST;
  nnum.Allocate(pw->NInit);
  nnum = 0;

  // no arrows will be plotted - no need to calculate the nnlist and rdf
  if (pw->arrNeighNum==0) {
    return true;
  }

  // Calculate the cutoff radius for seeking atomic neighbors. This number is used
  // to construct the linked neighbor list. If each cell is at least rcut x rcut x rcut,
  // the neighbors can be searched only in the adjacent cells.
  if (NEIGHRCUT > 0)  // given in .ddplot by user
    pw->rcut = NEIGHRCUT;
  else {  // no given value -> try to guess it -> may result in the error message if too large
    if (!pw->isGBfile) 
      pw->rcut = vlength(pw->period);
    else
      pw->rcut = pw->blSize(1)/10.0;  // this is only a guess - can be changed as we like
  }

  // calculate the radial distribution function
  NeighInit(pw);
  if (VERBOSE) {
    printf("* parameters of the constructed linked neighbor list:\n");
    printf("    number of cells along x y z:  %d %d %d\n", pw->ncell(1), pw->ncell(2), pw->ncell(3));
    printf("    cell size:  x=%0.1f, y=%0.1f, z=%0.1f\n", pw->cellsize(1), pw->cellsize(2), pw->cellsize(3));
  }
  NeighList(pw);

  ok = CalcRDF(pw);
  if (!ok)
    return false;
  
  if (VERBOSE) {
    printf("* calculated radial distribution function (distance, number of atomic pairs):\n");
    for (i=1; i<=pw->RdfNNeigh; i++) {
      if (pw->RdfDist.len[1] == 1)
	printf("    %7.4lf  %3d\n", pw->RdfDist(i), pw->RdfNum(i));	
      else
	printf("    %7.4lf-%7.4lf  %3d\n", pw->RdfDist(i,1), pw->RdfDist(i,2), pw->RdfNum(i));
    }
    
    printf("* constructing the linked list of atomic neighbors\n");
    printf("    NeighRCut = %7.4lf\n", pw->rcut);
    printf("  (if this cut-off radius is too large, ddplot says it exceeded MAX_NEIGHBORS ->\n");
    printf("   set NeighRCut manually in the .ddplot file)\n");
  }

  pw->nnpairs = 0;
  for (icen=1; icen<=pw->NInit; icen++) {
    // consider only atoms in the selected Z-layers
    if (!pw->zLayerSel( pw->zLayer(icen) ))
      continue;

    idx = 1;
  
    // get the indices of the cell in which atom icen resides
    GetCell(pw, icen, icell);

    // we will search also the neighboring cells - get the indices (pbc treated below)
    for (d=1; d<=3; d++) {
      icmin(d) = icell(d) - 1;
      icmax(d) = icell(d) + 1;
      if (d < 3) {
	if (icmin(d) == 0) icmin(d) = 1;
	if (icmax(d) == pw->ncell(d)+1) icmax(d) = pw->ncell(d);
      }
    }

    // search through all neighboring cells and itself
    for (iidx=icmin(1); iidx<=icmax(1); iidx++) {
      for (jidx=icmin(2); jidx<=icmax(2); jidx++) {
	for (kidx=icmin(3); kidx<=icmax(3); kidx++) {
	  if (kidx == 0)
	    ineigh =  pw->head(iidx,jidx,pw->ncell(3));
	  else if (kidx == pw->ncell(3)+1)
	    ineigh =  pw->head(iidx,jidx,1);
	  else
	    ineigh = pw->head(iidx,jidx,kidx);
	  
	  while (ineigh>0) {
	    // skip itself, make the list unidirectional
	    if (ineigh < icen || (ineigh == icen && kidx != 0 && kidx != pw->ncell(3)+1)) {
	      ineigh = pw->list(ineigh);
	      continue;
	    }

	    // consider only the neighboring atoms located in selected Z-layers
	    if (!pw->zLayerSel( pw->zLayer(ineigh) )) {
	      ineigh = pw->list(ineigh);
	      continue;
	    }
	    
	    dx = pw->xyzInit(ineigh,1) - pw->xyzInit(icen,1);
	    dy = pw->xyzInit(ineigh,2) - pw->xyzInit(icen,2);
	    if (kidx == 0)
	      dz = pw->xyzInit(ineigh,3) - pw->period(3) - pw->xyzInit(icen,3);
	    else if (kidx == pw->ncell(3)+1)
	      dz = pw->xyzInit(ineigh,3) + pw->period(3) - pw->xyzInit(icen,3);
	    else
	      dz = pw->xyzInit(ineigh,3) - pw->xyzInit(icen,3); 
	    
	    // calculate the distance between icen and ineigh
	    dist = sqrt(pow(dx,2) + pow(dy,2) + pow(dz,2));

	    // check the neighbor distances (arrNeighbors says how many
	    // shortest neighbor distances are regarded for plotting)      
	    if (dist<=pw->rcut) {
	      for (nn=1; nn<=pw->arrNeighNum; nn++) {
		if (pw->RdfDist.len[1] == 1) {
		  dmin = pw->RdfDist(pw->arrNeighbors(nn)) - 1e-4;
		  dmax = pw->RdfDist(pw->arrNeighbors(nn)) + 1e-4;
		} else {		
		  dmin = pw->RdfDist(pw->arrNeighbors(nn),1) - 1e-4;
		  dmax = pw->RdfDist(pw->arrNeighbors(nn),2) + 1e-4;
		}
		if (dist>=dmin && dist<=dmax) {
		  nnum(icen)++;
		  if (icen != ineigh) nnum(ineigh)++;
		  nnlist(icen,idx) = ineigh;
		  idx++;
		  break;
		}
	      }
	    }
	    
	    ineigh = pw->list(ineigh);
	  }
	}
      }
    }

    nnlist(icen,idx) = END_OF_LIST;
    pw->nnpairs += idx-1;
  }


  if (VERBOSE) {
    printf("* unidirectional linked neighbor list; [icen]<ineigh):\n");
    for (icen=1; icen<=pw->NInit; icen++) {
      idx = 1;
      printf("    [%d] ", icen);
      while (nnlist(icen,idx)!=END_OF_LIST) {
	ineigh = nnlist(icen,idx);
	printf("%d ", ineigh);
	idx++;
      }
      printf("\n");
    }
  }

  return true;
}


/*
  This function finds the nearest neighbors of atoms up to the cutoff distance
  specified by maxdist in the relaxed structure. 
*/

bool RelNeighborList(PltWin *pw, int rmax, IMatrix &nnlist, IVector &nnum)
{
  double dist, dx, dy, dz;
  IVector icell(3), icmin(3), icmax(3);
  int icen, ineigh, idx, d, iidx, jidx, kidx;

  // allocate the space for data
  nnlist.Allocate(pw->NRel,MAX_NEIGHBORS);
  nnlist.EnlargeStep(0,MAX_NEIGHBORS);
  nnlist = END_OF_LIST;
  nnum.Allocate(pw->NRel);
  nnum = 0;

  for (icen=1; icen<=pw->NRel; icen++) {
    // consider only atoms in the selected Z-layers
    if (!pw->zLayerSel( pw->zLayer(icen) ))
      continue;

    idx = 1;
  
    // get the indices of the cell in which atom icen resides
    GetCell(pw, icen, icell);

    // we will search also the neighboring cells - get the indices
    for (d=1; d<=3; d++) {
      icmin(d) = icell(d) - 1;
      icmax(d) = icell(d) + 1;
      if (d < 3) {
	if (icmin(d) == 0) icmin(d) = 1;
	if (icmax(d) == pw->ncell(d)+1) icmax(d) = pw->ncell(d);
      }
    }

    // search through all neighboring cells and itself
    for (iidx=icmin(1); iidx<=icmax(1); iidx++) {
      for (jidx=icmin(2); jidx<=icmax(2); jidx++) {
	for (kidx=icmin(3); kidx<=icmax(3); kidx++) {
	  if (kidx == 0)
	    ineigh =  pw->head(iidx,jidx,pw->ncell(3));
	  else if (kidx == pw->ncell(3)+1)
	    ineigh =  pw->head(iidx,jidx,1);
	  else
	    ineigh = pw->head(iidx,jidx,kidx);

	  while (ineigh>0) {
	    // skip itself, make the list unidirectional
	    if (ineigh < icen || (ineigh == icen && kidx != 0 && kidx != pw->ncell(3)+1)) {
	      ineigh = pw->list(ineigh);
	      continue;
	    }

	    // consider only the neighboring atoms located in selected Z-layers
	    if (!pw->zLayerSel( pw->zLayer(ineigh) )) {
	      ineigh = pw->list(ineigh);
	      continue;
	    }
	    
	    dx = pw->xyzRel(ineigh,1) - pw->xyzRel(icen,1);
	    dy = pw->xyzRel(ineigh,2) - pw->xyzRel(icen,2); 
	    if (kidx == 0)
	      dz = pw->xyzRel(ineigh,3) - pw->period(3) - pw->xyzRel(icen,3);
	    else if (kidx == pw->ncell(3)+1)
	      dz = pw->xyzRel(ineigh,3) + pw->period(3) - pw->xyzRel(icen,3);
	    else
	      dz = pw->xyzRel(ineigh,3) - pw->xyzRel(icen,3); 
	    
	    // calculate the distance between icen and ineigh
	    dist = sqrt(pow(dx,2) + pow(dy,2) + pow(dz,2));

	    // check the neighbor distances (arrNeighbors says how many
	    // shortest neighbor distances are regarded for plotting)      
	    if (dist<=rmax) {
	      nnum(icen)++;
	      if (icen != ineigh) nnum(ineigh)++;
	      nnlist(icen,idx) = ineigh;
	      idx++;
	      break;
	    }
	    
	    ineigh = pw->list(ineigh);
	  }
	}
      }
    }

    nnlist(icen,idx) = END_OF_LIST;
  }


  if (VERBOSE) {
    printf("* unidirectional linked neighbor list in the relaxed structure; [icen]<ineigh):\n");
    for (icen=1; icen<=pw->NRel; icen++) {
      idx = 1;
      printf("    [%d] ", icen);
      while (nnlist(icen,idx)!=END_OF_LIST) {
	ineigh = nnlist(icen,idx);
	printf("%d ", ineigh);
	idx++;
      }
      printf("\n");
    }
  }

  return true;
}



/* Calculation of the cell size and the number of cells that fill the block so that a neighbor of an
   atom will not be searched farther than in the immediately adjacent cells. */

void NeighInit(PltWin *pw)
{
  int d;

  for (d=1; d<=3; d++) {
    // number of cells in (x,y,z) directions
    pw->ncell(d) = 1 + trunc(pw->blSize(d) / (1.001*pw->rcut));

    // size of each cell's edge in (x,y,z) directions
    pw->cellsize(d) = pw->blSize(d) / pw->ncell(d);
    if (pw->cellsize(d) == 0.0)  pw->cellsize(d) = INF;  // can have 2D block this way
  }

  // initially all -1
  pw->head.Allocate(pw->ncell(1), pw->ncell(2), pw->ncell(3));
  pw->head = END_OF_LIST;
  pw->list.Allocate(pw->NInit);
}


/* Construct a linked neighbor list. Whole block is divided into separate cells whose width is
  larger than the cut-off radius rcut. The number of cells along each axis is stored in
  <ncell>. First atom (any atom) in each cell is stored as <head>. Then, <list> contains a chain of
  other atoms in the same cell. For example, if <head> equals to 15, go to list(15) to find the next
  atom. If list(15)=3, then go to list(3) and so on. If the list(#) gives -1, we are at the end of
  the list for this cell. */

void NeighList( PltWin *pw )
{
  IVector icell(3);
  int i, iidx, jidx, kidx;

  if (VERBOSE)
    printf("* constructing the linked neighbor list\n");

  for (i=1; i<=pw->NInit; i++) {
    // get the indices of the cell in which atom <i> lies
    GetCell( pw, i, icell );

    iidx = icell(1);
    jidx = icell(2);
    kidx = icell(3);

    pw->list(i) = pw->head(iidx,jidx,kidx);   // first in the list is -1 (terminator)
    pw->head(iidx,jidx,kidx) = i;             // head is the last atom
  }
}


/*
  Gives the indices of the cell in which atom <i> lies. For example, icell=(1,5,3) means that the
  atom is located in the first column along the x-direction, the fifth row along the y-direction and
  the third layer along the z-direction.
*/

void GetCell(PltWin *pw, int i, IVector &icell)
{
  int d;

  for (d=1; d<=3; d++) {
    icell(d) = 1 + (int) trunc((pw->xyzInit(i,d)-pw->xyzMin(d)) / pw->cellsize(d));

    // in exceptional cases it can happen that xyzInit(i,d) is exactly at the cell edge -> then
    // icell(d) = ncell(d)+1 and we need to subtract 1 to get the correct cell number
    if (icell(d) > pw->ncell(d) && pw->xyzInit(i,d)-pw->xyzMin(d)-pw->blSize(d) < 1e-6) 
      icell(d)--;

    if (icell(d) > pw->ncell(d) || icell(d) < 1) {
      msgError( err_AtomNotInCell );      
      printf("atom: %i\n", i);
      printf("dimension: %i\n", d);
      printf("cell number: %i\n", icell(d));
      printf("range of cells: (%i, %i)\n", 1, pw->ncell(d));
      printf("coordinate of the unrelaxed atom:  %0.4f\n", pw->xyzInit(i,d));
      exit(0);
    }
  }
}
